user  root; #进程用户，一般不使用root
worker_processes  auto; #进程数，auto即根据核心数生成进程数
worker_cpu_affinity auto; #多核情况下用哪些核，一般auto即可
worker_rlimit_nofile 51200; #nginx 最大文件打开数，一般与 ulimit -n 保持一致
error_log  /var/log/nginx/error.log warn; #日志记录位置和级别
pid        /var/run/nginx.pid; #pid位置
events {
	use epoll; #Linux内核2.6版本及以后就用这个
	multi_accept on;	#尽可能多地接受请求，打开就行
	worker_connections  4096; #同一时间nginx的一个进程可以处理的最大请求数，不宜设置的过高，会吃满内存
}
stream { #stream模块，一般用于四层代理(TCP、UDP)，请看下方示例，仅作参考，请不要直接复制运行
	#include /etc/nginx/forward.conf; #引用其他的配置文件，即可将下方的一部分写到另一个配置文件里，灵活使用
	##########################################
	upstream test1 {
		#默认均衡方式为轮询
		#hash $remote_addr consistent; #根据来访IP分流(常用)
		#least_conn; #最少连接数配置(商业版本)
		#random 随机
		server test1.com:8080 [weight 1(设置权重)];
		server test2.com:8080 [backup (设置备机,其他server均不可用时会启用,均衡方式为hash时不可用)];
		server test3.com:8080 [down (标记为不可用，一般用不到)];
		server test4.com:8080 [max_fails=number(失败尝试最大次数,超过后标记为不可用,默认为1)] [fail_timeout=time (定义超时后不可用标记保持多长时间,默认为10s)];
	}
	server {
		listen 8080 reuseport; 
		listen 8080 udp reuseport;
		proxy_pass test1;
	} 
	##########################################
	#后端只有一个时proxy_pass可以直接写域名端口
	server {
		listen 8081 reuseport;
		listen 8081 udp reuseport;
		proxy_pass test1.com:8080;
	}
	##########################################
	server {
		listen 443 reuseport ssl; 对本地TCP的8080端口进行tls加密
		proxy_pass 127.0.0.1:8080;
		ssl_certificate    /etc/nginx/tls/full_chain.pem;	
		ssl_certificate_key    /etc/nginx/tls/private.key;
		ssl_protocols       TLSv1.2 TLSv1.3;
		ssl_ciphers  ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
	}
	server {
		listen 8082 reuseport;
		proxy_ssl on; #上方TCP加密对应的解密
		proxy_ssl_protocols TLSv1.2 TLSv1.3;
		proxy_pass test1.com:443;
	}
	##########################################
	server { #通过nginx实现sniproxy的功能，即无证书反代https
		listen 143 reuseport;
		ssl_preread	on; #在preread阶段启用从ClientHello消息中提取信息，可以提取到请求Host
		#proxy_protocol on; #haproxy的proxy protocol协议，可以将真实请求IP发送至后端，这个需要和后端同时修改
		proxy_pass $sniproxy; #反代下下方的map
		proxy_connect_timeout 10s;#连接后端的超时时间
		proxy_timeout 10s; #接收后端的超时时间
		proxy_next_upstream_timeout 10s; #重试最大超时时间，默认0，即不限制
		tcp_nodelay on; #禁用Nagle，默认项，对延迟不敏感的可以尝试开启
		error_log  /var/log/nginx/sniproxy.error.log warn; #记录日志
	}
	map $ssl_preread_server_name $sniproxy { #根据$ssl_preread_server_name来分流
		test1.com test1; #域名为test1.com时，反代到test1后端
		test2.com test2; #域名为test2.com时，反代到test2后端
		default   test2.com;#若没匹配到上边的域名，则反带到test2后端
	}
	upstream test1 {#参考上边的stream规则
		server test1.com;
		server test1.cn;
	}
	upstream test2 {
		server test2.com;
		server test2.cn;
	}
}






